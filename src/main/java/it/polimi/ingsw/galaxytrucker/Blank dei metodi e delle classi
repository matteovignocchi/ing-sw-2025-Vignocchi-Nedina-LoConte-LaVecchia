
per il client la chiamata dei metodi dovrebbe essere : client->virtualCLient->virtualServer->server(model) e viceversa
con server intendo GameController


METODO GETTILESERVER()

CLIENT CHIAMA:
Tile tmp = virtualServer.getTileServer(//qua se ti serve passo qualcosa);

SERVER:
List<Tile> tmp1 = controller.getPileOfTIle();
VirtualServer.printListOfTIle(VirtualClient,tmp1);
int tmp = VirtualClient.askCordinate();
Tile tile = PileOfTiles.get(tmp);
PileOfTiles.remove(tmp);
VirtualServer.setGameFase(VirtualClient,TILE_MANAGEMENT);
VirtualServer.printTIle(VirtualCLient,tile);
return tile;

METODO GETUNCOVEREDTILE()

CLIENT CHIAMA:
Tile tmp = virtualServer.getUncoveredTile()

SERVER:
List<Tile> tmp1 = controller.getPileOfTIle();
VirtualServer.printListOfTIle(VirtualClient,tmp1);
int tmp = VirtualClient.askCordinate();
Tile tile = PileOfTiles.get(tmp);
PileOfTiles.remove(tmp);
VirtualServer.setGamePhase(VirtualClient,TILE_MANAGEMENT);
VirtualServer.printTIle(VirtualCLient,tile);
return tile;

i due metodi getTile modificano la fase del player in TILE_MANAGMENT prima di tornare la tile , quindi ora scriverò i metodi possibili qua

RETURN TILE()

CLIENT CHIAMA:
virtualClient.returnTile(tile);

Server :
controller.addTouncoveredTile(tile);
VirtualServer.setGameFase(VirtualClient,BOARD_SETUP);
VirtualServer.updateView(VirtualCLient);

PLACE TILE()

CLIENT:
VirtualClient.Place(tile)

SERVER:
int[] cord = VirtualServer.askCordinate(VirtualClient);
controller.addTileToPlayer(VirtualCLient(intendo id del player) , cord[0] , cord[1] , tile);
VirtualServer.setGamePhase(VirtualClient,BOARD_SETUP);
VirtualServer.updateView(VirtualCLient);

RIGHT E LEFT ROTATE ME LE GESTISCO IO DIREI A STO PUNTO


METODI CHE NON CAMBIANO DI FASE MAI:

LOGOUT()
Il client chiede di uscire dalla partita , non di togliere la connessione
per com'è scritto il codice :

CLIENT->VirtualClient.logOut()->VirtualServer.quitGame(nickname)->Ricavo in che partita si trova -> gameController.quitGame()
       ->VirtualServer.seGameFAse(VirtualClient , EXITS) -> VirtualServer.updateView(VirtualClient)


WATCH A SHIP:

CLIENT:
VirtualClient.watchAShip()
SERVER:
VirtualServer.printList(VirtualClient,Lista con scritto player1 , player 2 ....);
VirtualServer.inform(VirtualClient, "seleziona indice");
int index = VirtualServer.AskIndex(VirtualCLient);
VirtualServer.printDashBoard(VirtualClient , controller.getPlayersInGame.get(index).getDashBoard());

WATCH A DECK :

CLIENT:
VirtualClient.watchADeck();
SERVER:
VirtualServer.printList(VirtualClient,Lista con scritto deck1 deck2...);
VirtualServer.inform(VirtualClient, "seleziona indice");
int index = VirtualServer.AskIndex(VirtualCLient);
VirtualServer.printDeck(VirtualClient , controller.getDeck().get(index));

SPIN THE HOURGLASSES

CLIENT:
VirtualClient.rotateGlass();

SERVER:
di base:
trovo il controller della partita di riferimento  poi:
controller.spinHourglasses()
dopo che è finito il tread e ho aggiornato il parametro che indica quante volte ho spinnato finora:
forEachPlayer:
VirtualServer.UpdateView() // questo perche alla devo aggiornare il parametro di clessidra a schermo
la clessidra deve essere girata la terza volta solo da un player ready , quindi il controller fa sto controllo. se non è ready non succede nulla

DECLEAREADY:

VirtualClient.declareReady();

SERVER:
controller.setGamePhase(Nickname , WAITING_FOR_PLAYERS);
controller.checkPhasePlayer(WAITING_FOR_PLAYERS)
if(!controller.checkPhasePlayer(WAITING_FOR_PLAYERS)){
VirtualServer.setGamePhase(VirtualClient , WAITING_FOR_PLAYERS);
VirtualServer.updateView(VirtualClient);}
else{ // questo else va fatto anche per la questione clessidrà
ForEachplayer:
VirtualServer.setGamePhase(VirtualClient , WAITING_FOR_TURN);
VirtualServer.updateView(VirtualClient);
controller.checkAssembly();

solo per il primo player:
VirtualServer.setGamePhase(VirtualClient , DRAW_PHASE);
VirtualServer.updateView(VirtualClient);

}

IL FATIDICO DRAWCARD :

CLIENT :

VirtualClient.drawCard();

SERVER:
Card c = controller.drawCard();
ForEachPlayer :
VirtualServer.printCard(c);

dopo:
controller.activateCard(c);
la activate delle card bisogna scegliere come cambiarla
la cosa carina sarebbe avere per ogni player p su cui sto iterando:
VirtualServer.setGamePhase(VirtualClient , CARD_EFFECT);
VirtualServer.updateView(VirtualClient);
//effetto delle carte con i botta e risposta stampando nella view passando da virtualServer
VirtualServer.setGamePhase(VirtualClient , WAITING_FOR_TURN);
VirtualServer.updateView(VirtualClient);

finita la activate card bidogna individuare il nuovo primo giocatore e fare
VirtualServer.setGamePhase(VirtualClient , DRAW_PHASE);


Finite le carte o i player :
ForEachPlayer:
int[] finalScoring = controller.finalScore(player p);
VirtualServer.setGamePhase(VirtualClient , SCORING);
VirtualServer.updateView(VirtualClient);
VirtualServer.printFinalScoring(VirtualCLient , finalScoring)









//////////////////////// VECCHIE DESCRIZIONI SCRITTE PEGGIO /////////////////////////////////////////////////////////////////////////////////////////////////

    /// DA QUI METTERO' CORPO DEL METEODO GENERALE CHIAMATO DA ACTION MANAGMENT E UNA LISTA DI TUTTE LE AZIONI CHE SERVONON///

                       ///METODI SINGOLI DI FASE BOARD_SETUP E WAITING_FOR_PLAYER///

    /// getTileServer():
                            //cosa succede ?
                            //1) il server chiama il metodo printListTile del client passandogli tutto le tile coperte
                            //   e insieme a quella print farà una inform in cui chiedere di selezionare lindice che si vuole
                            //   e chimera il metod askIndex del client
                            //2) il client seleziionato l'indice e il server una volta riceveuto farà una update allo stato del
                            //   del client mandandolo in fase TILE_MANAGMENT stampandogli a schermo la tila nella posizione standardezionerà
    /// getUncoveredTile():
                            //cosa succede?
                            //1) il server chiama il metodo printListTile del client passandogli tutto le tile coperte
                            //   e insieme a quella print farà una inform in cui chiedere di selezionare lindice che si vuole
                            //   e chimera il metod askIndex del client
                            //2) il client seleziionato l'indice e il server una volta riceveuto farà una update allo stato del
                            //   del client mandandolo in fase TILE_MANAGMENT stampandogli a schermo la tila nella posizione standardezionerà




    /// Spin The Hourglass():
                            //cosa succede?
                            //1) il server chiamerà un metodo che fa partire un timeout e incrementa un contatore alla fine di quel timeout
                            //   tutti i client si vedranno una prima inform con "clessidra girata n: count+1" (dato che count parte da 0)
                            //   e avranno una Update view che farà incrementare un valore a schermo "clessidra alla fine del thread"
                            //   il metodo sarà sincronicazzato su se stesso ,ovvero finchè il thread non finisce anche se un giocatore lo clicca
                            //  non succederà nulla
                            //  bisogna fare in modo che se count è >=2 il metodo possa essere chiamato solo da chi è ready , e se lo chiama chi non ha il flag ready non succede nulla
                            //  alla fine di ogni thread ci sarà prima della update view() un metodo che controlla count , e se è >=3 cambierà lo stato a tutti
                            //  i giocatori mettondolo a pronto e il gameFase passerà a WAITING_FOR_TURN.
                            //  il controller farà una check di tutte le regole di assemblaggio e aggiornerà di nuovo le view dei player


    /// declearReady():
                            //cosa succede?
                            //1) il server chiamerà tramite controller il setter del flag ready del player associato
                            //2) dopo il set del flag farò una update game stste mettendo il singolo player in WAITING_FOR_PLAYERS

    ///  watch a deck() :
                            //1) server chiama la print list di virtual client, inform per chiedere lindice e ask index per avere
                            // lindice indietro
                            //2) ricevuto lindice dal client il server chiamera una print list of card sul client in modo tale da stampare
                            // a schermo le carte del deck

                       ///METODI PER GESTIONE DELLA FASE TILE MANAGMENT///



    /// returTile() :
                            //1) il server riceverà dal client tramite un listeners la tile e la farà inserire nella pila
                            // delle scoperte
                            // una volta fatto ciò farà una changegamesStatus riportandolo nella fase iniziale


    /// placeTile() :
                            //1) il server chiederà le cordinate di dove si vuole posizionare la tila , il client visualizzeà
                            // in automatico la zone delle discard pile , quindi il controllo se va bene o meno lo fa in automatico
                            // il controller per dire se è prenotato o meno ( basta avere solo in addTile il controllo , lo fsccio io)
                            // una voltà ricevute le cordinate e la tile il server la darà al controller e data al controller
                            // invierà la risposta direttamente al client
                            // se la tile è stata inserità con successo tornerò in fase iniziale ,altrimenti rimango in TILE_MANAGMENT


    /// rightRotatedTile() :
                            //1) il server riceve questa richiesta , va a prenderà la tile che possiede il client associato e
                            // la girà aggiornando con viewupdate la view del client ,rimango nella stessa fase

    ///leftRotatedTile() :
                            //uguale a su


                              ///METODI DELLA CARTA///
                            //una volta che tutti i player sono ready o l'ultima clessidrà il server posizionerà tutti player in
                            // WAITING_FOR_TURN , farà fare i controlli su tutte la plance al controller e metterà al primo giocatore che ha finito
                            // in gameFase DRAW_FASE e il resto rimane in WAITING_FOR_TURN

    /// drawCard_server() :
                            //1) server riceve il comdando e stampa a tutti a schermo la carta pescata , poi andando in ordine
                            // di posizioni fa per ogni player
                            // -changegameFase()->CARD_EFFECT e changeView , in modo tale che un player alla volta può lavorare sulla
                            // carta e interagire con la carta , mi pare che questa logica era già implementata direttamente nelle carte , qind
                            // si potrebbe farlo direttamente da li senza dover fare giri strani
                            // una volta finito si torna in WAITING_FOR_TURN , e quando tutti sono in WAITING_FOR_TURN il server posiziona il giocatore
                            // in testa in DRAW_FASE

                    ///METODI COMUNI SEMPRE///


    /// lookDashBoard() :
                            //1) server stampa al client lista di player in game e richiede indice , il client a questo punto
                            // manda l'indice e una volta ricevuto il server stampa la nave a schermo del client dell,indice richiesto
                            // tramite un metodo apposta del client del tipo :printSHIP(TILE[][] T) e quello ci pensa poi la tui

    /// logOut() :
                            //fa uscire il player dalla parita , non fa fare la disconnessione con il server


//////////// COSE DI ME E TEO //////////////////////////////////////////////////////////////////////////////////////////////////////////

//public boolean askPlayerDecision() {
    // ButtonType buttonYes = new ButtonType("Yes", ButtonBar.ButtonData.YES);
    //    ButtonType buttonNo = new ButtonType("No", ButtonBar.ButtonData.NO);
    //    Alert choice = new Alert(Alert.AlertType.CONFIRMATION);
    //    choice.setTitle("Choose your action");
    //    choice.setHeaderText(null);
    //    Optional<ButtonType> result = choice.showAndWait();
    //    return result.isPresent() && result.get().equals(buttonYes);
    //}


    //    //metodo gestione di che posso fare
//    private static void handleMainActionPhase() throws Exception{
//        //chiedo ad oleg domani, prima non devo fare l'update della view perchè prima vedo
//        //la mainActionPhase poi scelgo cosa fare
//        view.updateState(FASE0);
//        view.inform("Possible actions:");
//        List<String> possibleActions = virtualClient.getAvailableAction();
//
//        for(int i = 0 ; i < possibleActions.size(); i++){
//            view.inform((i+1)+"."+possibleActions.get(i));
//        }
//        int choice = virtualClient.askIndex();
//        //chiedere perchè send action non è un void ma è un string
//        String result = virtualClient.sendAction(possibleActions.get(choice-1));
//    }

//    private static void handleChoosingCoveredTile() throws Exception{
//        view.updateState(FASE1);
//        //per fare più easy possiamo che ci da soltanto il numero di tessere coperte, che tanto passo da 151 circa,
//        //quindi mandare ogni volta la lista che risulta pesante
//        List<Tile> pile = virtualClient.getPileOfTile();
//        view.printList("pile", pile);
//        //VERSIONE 2
//        //int totalTile = virtualClient.getNumOfTile();
//        //view.printCovered(totalTile);
//        view.inform("Choose one of covered tile and give the index");
//        int index = virtualClient.askIndex();
//        //l'ho pensato così forse è sbagliato
//        Tile tile = virtualClient.getTile(index -1);
//        view.printTile(tile);
//        view.inform("Possible actions:");
//        List<String> possibleActions = virtualClient.getAvailableAction();
//        for(int i = 0 ; i < possibleActions.size(); i++){
//            view.inform((i+1)+"."+possibleActions.get(i));
//        }
//        int choice = virtualClient.askIndex();
//        String result = virtualClient.sendAction(possibleActions.get(choice -1));
//
//    }
//
//    private static void handleBuildingPhase() throws Exception{
//        view.updateState(FASE2);
//        view.inform("Choose one of slots and give the indexes");
//        int[] coordinate = view.askCordinate();
//        //qua credo ci vada il send coordinates però dobbiamo creare il metodo
//    }
//
}
